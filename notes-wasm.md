# Test native

```
cargo test --release --test poseidon test_poseidon_n -- --nocapture
```

# Test wasm

```
wasm-pack test --release --firefox --headless --test poseidon_wasm -- test_poseidon_n --nocapture
```

# Build test wasm

```
cargo test --release --test poseidon_wasm --no-run --target wasm32-unknown-unknown
```

# Build lib wasm

```
cargo build --release --target wasm32-unknown-unknown
```

# Build and review the output

## Review the wasm assembly
From the folder `wasm`:
```
cargo build --release --target wasm32-unknown-unknown
wasm2wat ../target/wasm32-unknown-unknown/release/wasm_test.wasm -o wasm_test.wat
```

Then in `wasm_test.wat` find the relevant function.

## Review the code generated by Spidermonkey (the Firefox js engine)

Download jsshell from https://archive.mozilla.org/pub/firefox/nightly/latest-mozilla-central/jsshell-linux-x86_64.zip
Start it and run the following lines:
```
m = new WebAssembly.Module(os.file.readFile("add.wasm","binary"));
c = wasmExtractCode(m);
os.file.writeTypedArrayToFile('out.bin', c.code);
```
Then disassembley the result using radare2
```
rasm2 -S intel -a x86 -b 64 -D -B -f out.bin
```

## Native compilation generated code
```
cargo build --release
objdump -d ../target/release/libwasm_test.so
```
Then in the disassembly output find the relevant function.

## `GoldilocksField Add`

### Rust source
```rust
fn add(self, rhs: Self) -> Self {
    let (sum, over) = self.0.overflowing_add(rhs.0);
    let (mut sum, over) = sum.overflowing_add((over as u64) * EPSILON);
    if over {
        // NB: self.0 > Self::ORDER && rhs.0 > Self::ORDER is necessary but not sufficient for
        // double-overflow.
        // This assume does two things:
        //  1. If compiler knows that either self.0 or rhs.0 <= ORDER, then it can skip this
        //     check.
        //  2. Hints to the compiler how rare this double-overflow is (thus handled better with
        //     a branch).
        assume(self.0 > Self::ORDER && rhs.0 > Self::ORDER);
        branch_hint();
        sum += EPSILON; // Cannot overflow.
    }
    Self(sum)
}
```

### WASM
```wat
  (func $test_goldilocks_add (type 15)
    (local i64 i64)
    call $get_input ;; [a]
    local.tee 0 ;; $0 = a [a]
    call $get_input ;; [a, b]
    i64.add ;; sum0 = a+b [sum0]
    local.tee 1 ;; $1 = sum0;
    i64.const 4294967295 ;; [sum0, 0xffffffff]
    i64.const 0 ;; [sum0, 0xffffffff, 0]
    local.get 1 ;; [sum0, 0xffffffff, 0, sum0]
    local.get 0 ;; [sum0, 0xffffffff, 0, sum0, a]
    i64.lt_u ;; over0 = sum0 < a [sum0, 0xffffffff, 0, over0]
    select ;; [sum0, over0 ? 0xffffffff : 0]
    i64.add ;; sum1 = sum0 + (over0 ? 0xffffffff : 0) [sum1]
    local.tee 0 ;; $0 = sum1 [sum1]
    i64.const 4294967295 ;; [sum1, 0xffffffff]
    i64.add ;; [sum1 + 0xffffffff]
    local.get 0 ;; [sum1 + 0xffffffff, sum1]
    local.get 0 ;; [sum1 + 0xffffffff, sum1, sum1]
    local.get 1 ;; [sum1 + 0xffffffff, sum1, sum1, sum0]
    i64.lt_u ;; over1 = sum1 < sum0 [sum1 + 0xffffffff, sum1, over1]
    select ;; sum2 = over1 ? sum1 + 0xffffffff ; sum1 [sum2]
    call $set_output)
```

### Spidermonkey generated code (x86_64):
```
;; rdi is a
;; rsi is b
```
```
0x00000050   1                       55  push rbp
0x00000051   3                   4889e5  mov rbp, rsp
0x00000054   3                   4803f7  add rsi, rdi
0x00000057   5               b9ffffffff  mov ecx, 0xffffffff
0x0000005c   2                     33c0  xor eax, eax
0x0000005e   3                   483bf7  cmp rsi, rdi
0x00000061   4                 480f43c8  cmovae rcx, rax
0x00000065   3                   4803ce  add rcx, rsi
0x00000068   3                   4889c8  mov rax, rcx
0x0000006b   6             41bbffffffff  mov r11d, 0xffffffff
0x00000071   3                   4903c3  add rax, r11
0x00000074   3                   483bce  cmp rcx, rsi
0x00000077   4                 480f43c1  cmovae rax, rcx
0x0000007b   1                       5d  pop rbp
0x0000007c   1                       c3  ret
```

### Native x86_64 generated code
```
;; rdi is a
;; rsi is b
```
```
12e90:       b9 ff ff ff ff          mov    ecx,0xffffffff
12e95:       31 c0                   xor    eax,eax
12e97:       48 01 f7                add    rdi,rsi
12e9a:       48 0f 42 c1             cmovb  rax,rcx
12e9e:       48 01 f8                add    rax,rdi
12ea1:       73 03                   jae    12ea6 <test_goldilocks_add+0x16>
12ea3:       48 01 c8                add    rax,rcx
12ea6:       c3                      ret
```

Without the `branch_hint`:
```
12e90:       31 c9                   xor    ecx,ecx
12e92:       48 01 f7                add    rdi,rsi
12e95:       b8 ff ff ff ff          mov    eax,0xffffffff
12e9a:       48 0f 42 c8             cmovb  rcx,rax
12e9e:       48 01 f9                add    rcx,rdi
12ea1:       48 8d 04 01             lea    rax,[rcx+rax*1]
12ea5:       48 0f 43 c1             cmovae rax,rcx
12ea9:       c3                      ret
```

## x86_64 notes

- Flags:
   - CF: Carry Flag
   - ZF: Zero Flag
- `cmovb dst, src`: Move `src` to `dst` if `CF=1`
   - After a `cmp a, b`, Move if below (a < b)
- `cmovae dst, src`: Move `src` to `dst` if `CF=0`
   - After a `cmp a, b`, Move if above or equal (a >= b)
- `cmovbe dst, src`: Move `src` to `dst` if `CF=1 or ZF=1`
   - After a `cmp a, b`, Move if blelow or equal (a <= b) 
